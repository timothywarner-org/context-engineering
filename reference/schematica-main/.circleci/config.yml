# Schematica - Complete CI/CD Pipeline
# Pipeline: build → tests (parallel) → staging → approval → production
#
# Architecture:
#   - Images: GitHub Packages (ghcr.io)
#   - Staging: Azure Container App (schematica-staging)
#   - Production: Azure Container App (schematica)

version: 2.1

# ============================================
# ORBS
# ============================================
orbs:
  node: circleci/node@5.2.0
  azure-cli: circleci/azure-cli@1.2.2
  slack: circleci/slack@4.13.3

# ============================================
# PIPELINE PARAMETERS
# ============================================
parameters:
  image_name:
    type: string
    default: "ghcr.io/timothywarner-org/schematica"
    description: "Container image name in GitHub Packages"

  node_version:
    type: string
    default: "20.10"
    description: "Node.js version for builds"

# ============================================
# EXECUTORS
# ============================================
executors:
  node-executor:
    docker:
      - image: cimg/node:<< pipeline.parameters.node_version >>
    working_directory: ~/project
    resource_class: medium

  machine-executor:
    machine:
      image: ubuntu-2204:current
    working_directory: ~/project
    resource_class: medium

# ============================================
# COMMANDS
# ============================================
commands:
  setup-node-deps:
    description: "Install Node.js dependencies with caching"
    steps:
      - restore_cache:
          keys:
            - v1-deps-{{ checksum "package-lock.json" }}
            - v1-deps-
      - run:
          name: Install dependencies
          command: npm ci
      - save_cache:
          key: v1-deps-{{ checksum "package-lock.json" }}
          paths:
            - node_modules

  ghcr-login:
    description: "Authenticate to GitHub Container Registry"
    steps:
      - run:
          name: Login to GHCR
          command: |
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin

  azure-oidc-login:
    description: "Authenticate to Azure using OIDC"
    steps:
      - run:
          name: Azure OIDC Login
          command: |
            echo "Authenticating to Azure with OIDC..."
            az login --service-principal \
              --username "${AZURE_CLIENT_ID}" \
              --tenant "${AZURE_TENANT_ID}" \
              --password "${AZURE_CLIENT_SECRET}" \
              --output none
            az account set --subscription "${AZURE_SUBSCRIPTION_ID}"
            echo "Successfully authenticated to Azure"

  deploy-to-azure:
    description: "Deploy container to Azure Container Apps"
    parameters:
      environment:
        type: string
      app_name:
        type: string
      replicas:
        type: integer
        default: 1
    steps:
      - run:
          name: Deploy to << parameters.environment >>
          command: |
            SHORT_SHA=$(echo ${CIRCLE_SHA1} | cut -c1-7)
            IMAGE="<< pipeline.parameters.image_name >>:${SHORT_SHA}"

            echo "═══════════════════════════════════════════"
            echo "Deploying to << parameters.environment >>"
            echo "═══════════════════════════════════════════"
            echo "Image: ${IMAGE}"
            echo "App: << parameters.app_name >>"
            echo "Replicas: << parameters.replicas >>"
            echo ""

            az containerapp update \
              --name "<< parameters.app_name >>" \
              --resource-group "${AZURE_RESOURCE_GROUP}" \
              --image "${IMAGE}" \
              --min-replicas << parameters.replicas >> \
              --max-replicas $(( << parameters.replicas >> * 3 )) \
              --revision-suffix "rev-${SHORT_SHA}" \
              --output none

            FQDN=$(az containerapp show \
              --name "<< parameters.app_name >>" \
              --resource-group "${AZURE_RESOURCE_GROUP}" \
              --query "properties.configuration.ingress.fqdn" \
              --output tsv)

            echo ""
            echo "✓ Deployment complete!"
            echo "URL: https://${FQDN}"
      - run:
          name: Verify << parameters.environment >> health
          command: |
            FQDN=$(az containerapp show \
              --name "<< parameters.app_name >>" \
              --resource-group "${AZURE_RESOURCE_GROUP}" \
              --query "properties.configuration.ingress.fqdn" \
              --output tsv)

            echo "Checking health endpoint..."
            for i in {1..10}; do
              if curl -sf "https://${FQDN}/health" | grep -q "healthy"; then
                echo "✓ << parameters.environment >> deployment verified!"
                exit 0
              fi
              echo "Waiting for << parameters.environment >> to be ready... (attempt $i/10)"
              sleep 10
            done
            echo "✗ Health check failed!"
            exit 1

  notify-slack:
    description: "Send Slack notification"
    parameters:
      event:
        type: enum
        enum: ["pass", "fail", "always"]
        default: "always"
      message:
        type: string
        default: ""
    steps:
      - slack/notify:
          event: << parameters.event >>
          custom: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Schematica: ${CIRCLE_JOB}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*Branch:*\n${CIRCLE_BRANCH}"},
                    {"type": "mrkdwn", "text": "*Commit:*\n${CIRCLE_SHA1:0:7}"},
                    {"type": "mrkdwn", "text": "*Author:*\n${CIRCLE_USERNAME}"},
                    {"type": "mrkdwn", "text": "*Build:*\n<${CIRCLE_BUILD_URL}|#${CIRCLE_BUILD_NUM}>"}
                  ]
                }
              ]
            }

# ============================================
# JOBS
# ============================================
jobs:
  # ==========================================
  # BUILD - Lint, typecheck, compile, Docker
  # ==========================================
  build:
    executor: machine-executor
    steps:
      - checkout
      - run:
          name: Setup Node.js
          command: |
            nvm install << pipeline.parameters.node_version >>
            nvm use << pipeline.parameters.node_version >>
            node --version
      - restore_cache:
          keys:
            - v1-deps-{{ checksum "package-lock.json" }}
            - v1-deps-
      - run:
          name: Install dependencies
          command: npm ci
      - save_cache:
          key: v1-deps-{{ checksum "package-lock.json" }}
          paths:
            - node_modules
      - run:
          name: Run ESLint
          command: npm run lint
      - run:
          name: Run TypeScript type check
          command: npm run typecheck
      - run:
          name: Build TypeScript
          command: npm run build
      - run:
          name: Build Docker image
          command: |
            SHORT_SHA=$(echo ${CIRCLE_SHA1} | cut -c1-7)

            echo "Building Docker image..."
            docker build \
              --tag << pipeline.parameters.image_name >>:${SHORT_SHA} \
              --tag << pipeline.parameters.image_name >>:latest \
              --label "org.opencontainers.image.revision=${CIRCLE_SHA1}" \
              --label "org.opencontainers.image.created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              .

            mkdir -p /tmp/docker-images
            docker save << pipeline.parameters.image_name >>:${SHORT_SHA} > /tmp/docker-images/schematica.tar
            echo "✓ Docker image built: << pipeline.parameters.image_name >>:${SHORT_SHA}"
      - persist_to_workspace:
          root: /tmp
          paths:
            - docker-images
      - persist_to_workspace:
          root: .
          paths:
            - dist
            - node_modules

  # ==========================================
  # UNIT TESTS - Fan-out job 1
  # ==========================================
  unit-tests:
    executor: node-executor
    steps:
      - checkout
      - setup-node-deps
      - run:
          name: Run unit tests
          command: npm run test:unit -- --ci --reporters=default --reporters=jest-junit
          environment:
            JEST_JUNIT_OUTPUT_DIR: ./test-results/unit
      - store_test_results:
          path: ./test-results/unit
      - store_artifacts:
          path: ./test-results/unit

  # ==========================================
  # INTEGRATION TESTS - Fan-out job 2
  # ==========================================
  integration:
    executor: node-executor
    steps:
      - checkout
      - setup-node-deps
      - run:
          name: Run integration tests
          command: npm run test:integration -- --ci --reporters=default --reporters=jest-junit
          environment:
            JEST_JUNIT_OUTPUT_DIR: ./test-results/integration
      - store_test_results:
          path: ./test-results/integration
      - store_artifacts:
          path: ./test-results/integration

  # ==========================================
  # SECURITY SCAN - Fan-out job 3
  # ==========================================
  security:
    executor: node-executor
    steps:
      - checkout
      - setup-node-deps
      - run:
          name: Run security tests
          command: npm run test:security -- --ci --reporters=default --reporters=jest-junit
          environment:
            JEST_JUNIT_OUTPUT_DIR: ./test-results/security
      - run:
          name: Run npm audit
          command: npm audit --audit-level=moderate || true
      - store_test_results:
          path: ./test-results/security
      - store_artifacts:
          path: ./test-results/security

  # ==========================================
  # DEPLOY STAGING - Fan-in (waits for all tests)
  # ==========================================
  deploy-staging:
    executor: machine-executor
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - ghcr-login
      - run:
          name: Push image to GHCR
          command: |
            docker load < /tmp/docker-images/schematica.tar
            SHORT_SHA=$(echo ${CIRCLE_SHA1} | cut -c1-7)

            echo "Pushing to GitHub Packages..."
            docker push << pipeline.parameters.image_name >>:${SHORT_SHA}

            # Also push latest on main branch
            if [ "${CIRCLE_BRANCH}" = "main" ]; then
              docker tag << pipeline.parameters.image_name >>:${SHORT_SHA} << pipeline.parameters.image_name >>:latest
              docker push << pipeline.parameters.image_name >>:latest
            fi

            echo "✓ Image pushed to GHCR"
      - azure-cli/install
      - azure-oidc-login
      - deploy-to-azure:
          environment: staging
          app_name: "${AZURE_CONTAINERAPPS_NAME}-staging"
          replicas: 1
      - notify-slack:
          event: pass
          message: "Deployed to staging"

  # ==========================================
  # DEPLOY PRODUCTION - After approval
  # ==========================================
  deploy-production:
    executor: machine-executor
    steps:
      - checkout
      - azure-cli/install
      - azure-oidc-login
      - deploy-to-azure:
          environment: production
          app_name: "${AZURE_CONTAINERAPPS_NAME}"
          replicas: 2
      - notify-slack:
          event: pass
          message: "Deployed to production"

# ============================================
# WORKFLOWS
# ============================================
workflows:
  version: 2

  # ==========================================
  # MAIN PIPELINE
  # build → tests (fan-out) → staging (fan-in) → approval → production
  # ==========================================
  schematica-pipeline:
    jobs:
      # Stage 1: BUILD
      - build

      # Stage 2: FAN-OUT (3 parallel tests after build)
      - unit-tests:
          requires:
            - build

      - integration:
          requires:
            - build

      - security:
          requires:
            - build

      # Stage 3: FAN-IN (staging waits for ALL tests)
      - deploy-staging:
          requires:
            - unit-tests
            - integration
            - security
          filters:
            branches:
              only: main
          context:
            - ghcr-credentials
            - azure-credentials
            - slack-credentials

      # Stage 4: APPROVAL (main branch only, human gate)
      # Approver: timothywarner316@gmail.com
      - hold-for-approval:
          type: approval
          requires:
            - deploy-staging
          filters:
            branches:
              only: main

      # Stage 5: DEPLOY PRODUCTION (after approval)
      - deploy-production:
          requires:
            - hold-for-approval
          filters:
            branches:
              only: main
          context:
            - azure-credentials
            - slack-credentials

  # ==========================================
  # PR VALIDATION (non-main branches)
  # ==========================================
  pr-validation:
    jobs:
      - build:
          filters:
            branches:
              ignore: main

      - unit-tests:
          requires:
            - build
          filters:
            branches:
              ignore: main

      - integration:
          requires:
            - build
          filters:
            branches:
              ignore: main

      - security:
          requires:
            - build
          filters:
            branches:
              ignore: main
